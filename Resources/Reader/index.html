<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Title - Chapter 1 - Issue Name</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="description" content="Title" >
		<meta name="keywords" content="Spiraloid, 3Dcomic.shop, 3DComic,3DGraphicNovel, 3D Graphic Novel, 3D Comic, Online Graphic Novel, Digital Comic, Comic, comics, comix, Graphic Novel, 3D Art, 3D model, Concept Art, Digital Painting, VFX">
		<meta name="author" content="Author">

		<link href="./apple-touch-icon.png" rel="apple-touch-icon">
		<link rel="manifest" href="./manifest.json">

		<link href="https://3dcomic.shop/Inkbots/SiteThumbnail.jpg" rel="image_src">
		<link href="./favicon.ico" rel="fav-icon">

		<style>
			* {
				box-sizing: border-box;
			}

			html, body {
				background-color: rgb(13, 21, 29);
				margin: 0px;
				height: 100%;
			}

			#canvas {
				position: fixed;
				display: block;
				width: 100%;
				height: 100%;
			}

			#content {
				margin: auto;
				width: 100%;
				max-width: 1024px;
				display: flex;
				flex-wrap: wrap;
			}
		</style>
	</head>
	<body>

		<canvas id="canvas"></canvas>

		<div id="content"></div>

		<script src="js/three.js"></script>
		<script src="js/orbitcontrols.js"></script>
		<script src="js/gltfloader.js"></script>
		<script src="js/tween.js"></script>
		<script src="files.js"></script>

		<script>

			var canvas = document.getElementById( 'canvas' );
			var content = document.getElementById( 'content' );

			var camera, scene, renderer;
			var scenes = [];

			var isPointerDown = false;
			var pointer = new THREE.Vector2();
			var pointerOnDown = new THREE.Vector2();

			var language = 'en';

			if ( window.location.search.substr( 0, 5 ) === '?lan=' ) {

				language = window.location.search.substr( 5 );

			}

			init();
			loadFiles();
			animate();

			function init() {

				renderer = new THREE.WebGLRenderer( { canvas: canvas, antialias: true } );
				renderer.setClearColor( 0x131313 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.BasicShadowMap;
				renderer.outputEncoding = THREE.sRGBEncoding;

				document.body.addEventListener( 'pointerdown', onPointerDown );
				document.body.addEventListener( 'pointermove', onPointerMove );
				document.body.addEventListener( 'pointerout', onPointerUp );
				document.body.addEventListener( 'pointerup', onPointerUp );

			}

			function onPointerDown( event ) {

				isPointerDown = true;

				pointerOnDown.x = event.clientX;
				pointerOnDown.y = event.clientY;

			}

			function onPointerMove( event ) {

				pointer.x = event.clientX;
				pointer.y = event.clientY;

			}

			function onPointerUp() {

				isPointerDown = false;

			}

			function loadFiles() {

				var loader = new THREE.GLTFLoader();

				for ( var i = 0; i < files.length; i ++ ) {

					loadFile( files[ i ].replace( '${lan}', language ) );

				}

				function loadFile( path ) {

					var aspect = 1;

					var width = 100;
					var height = 100;

					var parts = path.split( '.' );
					var regex = /^w([0-9]+)h([0-9]+)/;
					var result = regex.exec( parts[ parts.length - 2 ] );

					if ( result !== null ) {

						width = result[ 1 ];
						height = result[ 2 ];

					}

					var element = document.createElement( 'div' );
					element.className = 'panel';
					element.style.display = 'inline-block';
					element.style.width = width + '%';
					// Hack: Maintain aspect ratio in divs
					// https://css-tricks.com/aspect-ratio-boxes/
					element.style.height = '0';
					element.style.paddingTop = ( height / aspect ) + '%';
					content.appendChild( element );

					var colors = new Uint8Array( [ 0, 0, 255 ] );
					var gradientMap = new THREE.DataTexture( colors, 3, 1, THREE.LuminanceFormat );
					gradientMap.minFilter = THREE.NearestFilter;
					gradientMap.magFilter = THREE.NearestFilter;
					gradientMap.generateMipmaps = false;

					loader.load( path, function ( gltf ) {

						var scene = gltf.scene;

						var camera, cameraOrigin, cameraTarget;
						var letters;

						scene.traverse( function ( child ) {

							if ( /^Camera\d{4}$/.test( child.name ) ) cameraOrigin = child;
							if ( /^Camera_aim\d{4}$/.test( child.name ) ) cameraTarget = child;
							if ( /^Letters_\w+\d{4}$/.test( child.name ) ) letters = child;

							//

							if ( child.isPerspectiveCamera ) {

								camera = child.clone();
								camera.userData.vFov = camera.fov;

							}

							if ( child.isLight ) {

								child.castShadow = true;
								child.shadow.mapSize.set( 1024, 1024 );
								child.shadow.autoUpdate = false;
								child.shadow.needsUpdate = true;

							}

							if ( child.isMesh && child.material.isMeshStandardMaterial ) {

								child.castShadow = true;
								child.receiveShadow = true;

								var color = child.material.color;

								child.material = new THREE.MeshToonMaterial( {
									color: color,
									gradientMap: gradientMap
								} );

							}

						} );

						var mixer = new THREE.AnimationMixer( scene );
						gltf.animations.forEach( function ( clip ) {

							mixer.clipAction( clip ).play();
							scene.userData.duration = clip.duration;

						} );

						//

						if ( camera ) {

							scene.add( camera );

							if ( cameraOrigin ) {

								camera.position.copy( cameraOrigin.position );
								camera.rotation.copy( cameraOrigin.rotation );

							}

							if ( letters ) {

								letters.position.set( 0, 0, - 2 );
								letters.rotation.set( 0, 0, 0 );

								camera.add( letters );

							}

						}

						scene.userData.camera = camera;
						scene.userData.cameraOrigin = cameraOrigin;
						scene.userData.cameraTarget = cameraTarget;

						scene.userData.element = element;
						scene.userData.mixer = mixer;

						scenes.push( scene );

					} );

				}

			}

			function updateSize() {

				var width = canvas.clientWidth;
				var height = canvas.clientHeight;
				var dpr = window.devicePixelRatio;

				if ( canvas.width !== width * dpr || canvas.height !== height * dpr ) {

					renderer.setSize( width, height, false );

				}

			}

			function animate() {

				render();
				requestAnimationFrame( animate );

			}

			function render() {

				updateSize();

				// canvas.style.transform = `translateY(${window.scrollY}px)`;

				renderer.setScissorTest( false );
				renderer.clear();

				renderer.setScissorTest( true );

				scenes.forEach( function ( scene ) {

					var element = scene.userData.element;
					var rect = element.getBoundingClientRect();

					if ( rect.bottom < 0 || rect.top > renderer.domElement.clientHeight ||
						 rect.right < 0 || rect.left > renderer.domElement.clientWidth ) {

						return; // it's off screen

					}

					var width = rect.right - rect.left;
					var height = rect.bottom - rect.top;
					var left = rect.left;
					var bottom = renderer.domElement.clientHeight - rect.bottom;

					renderer.setViewport( left, bottom, width, height );
					renderer.setScissor( left, bottom, width, height );

					var camera = scene.userData.camera;
					camera.aspect = rect.width / rect.height;
					camera.fov = camera.userData.vFov;

					if ( camera.aspect < 1 ) {
						// Use horizontal fov in vertical aspect ratios
						camera.fov = Math.atan( Math.tan( camera.fov * Math.PI / 360 ) / camera.aspect ) * 360 / Math.PI;
					}

					camera.updateProjectionMatrix();

					var time = THREE.Math.mapLinear( rect.top, renderer.domElement.clientHeight, - rect.height, 0, 1 );
					var duration = scene.userData.duration;

					var mixer = scene.userData.mixer;
					mixer.setTime( time * duration );

					//

					var isPointerInFrame = pointer.y < rect.bottom && pointer.y > rect.top;

					var cameraOrigin = scene.userData.cameraOrigin;
					var cameraTarget = scene.userData.cameraTarget;

					if ( cameraOrigin ) {

						if ( isPointerDown && isPointerInFrame ) {

							camera.position.x = cameraOrigin.position.x - ( ( pointer.x - pointerOnDown.x ) * 0.01 );
							camera.position.y = cameraOrigin.position.y + ( ( pointer.y - pointerOnDown.y ) * 0.01 );
							camera.position.z = cameraOrigin.position.z;

						} else {

							camera.position.x += ( cameraOrigin.position.x - camera.position.x ) * 0.4;
							camera.position.y += ( cameraOrigin.position.y - camera.position.y ) * 0.4;
							camera.position.z += ( cameraOrigin.position.z - camera.position.z ) * 0.4;

						}

					}

					if ( cameraTarget ) {

						camera.lookAt( cameraTarget.position );

					}

					renderer.render( scene, camera );

				} );

			}

		</script>
	</body>
</html>
