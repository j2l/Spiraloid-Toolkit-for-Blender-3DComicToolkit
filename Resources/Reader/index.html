<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Title - Chapter 1 - Issue Name</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="description" content="Title - A 3D Comic by Author - Chapter 1 -  Issue Name" >
		<meta name="keywords" content="Spiraloid, 3Dcomic.shop, 3D Comic, Online Graphic Novel, Digital Comic, Comic, comics, comix, Graphic Novel, 3D Art, 3D model, Concept Art, Digital Painting, VFX">
		<meta name="author" content="Author">

		<link href="./apple-touch-icon.png" rel="apple-touch-icon">
		<link rel="manifest" href="./manifest.json">

		<link href="https://3dcomic.shop/NaniteFulcrumChronicles/SiteThumbnail.jpg" rel="image_src">
		<link href="./favicon.ico" rel="fav-icon">

		<style>
			* {
				box-sizing: border-box;
			}

			html, body {
				background-color: #000000;
				margin: 0px;
				height: 100%;
			}

			#canvas {
				position: fixed;
				display: block;
				width: 100%;
				height: 100%;
			}

			#content {
				margin: auto;
				width: 100%;
				max-width: 1024px;
				display: flex;
				flex-wrap: wrap;
			}
		</style>
	</head>
	<body>

		<canvas id="canvas"></canvas>

		<div id="content"></div>

		<script src="js/three.js"></script>
		<script src="js/orbitcontrols.js"></script>
		<script src="js/gltfloader.js"></script>
		<script src="js/tween.js"></script>
		<script src="files.js"></script>

		<script>

			var canvas = document.getElementById( 'canvas' );
			var content = document.getElementById( 'content' );

			var camera, scene, renderer;
			var scenes = [];

			var lastScrollY = 0;
			var needsRender = false;

			init();
			loadFiles();
			animate();

			function init() {

				renderer = new THREE.WebGLRenderer( { canvas: canvas, antialias: true } );
				renderer.setClearColor( 0x131313 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.BasicShadowMap;
				renderer.outputEncoding = THREE.sRGBEncoding;

			}

			function loadFiles() {

				var loader = new THREE.GLTFLoader();

				for ( var i = 0; i < files.length; i ++ ) {

					loadFile( files[ i ] );

				}

				function loadFile( path ) {

					var aspect = 16 / 9;

					var width = 100;
					var height = 100;

					var parts = path.split( '.' );
					var regex = /^w([0-9]+)h([0-9]+)/;
					var result = regex.exec( parts[ parts.length - 2 ] );

					if ( result !== null ) {

						width = result[ 1 ];
						height = result[ 2 ];

					}

					var element = document.createElement( 'div' );
					element.className = 'panel';
					element.style.display = 'inline-block';
					element.style.width = width + '%';
					// Hack: Maintain aspect ratio in divs
					// https://css-tricks.com/aspect-ratio-boxes/
					element.style.height = '0';
					element.style.paddingTop = ( height / aspect ) + '%';
					content.appendChild( element );

					var colors = new Uint8Array( [ 0, 0, 0, 0, 0, 0, 255, 255, 255 ] );
					var gradientMap = new THREE.DataTexture( colors, 3, 1, THREE.RGBFormat );
					gradientMap.minFilter = THREE.NearestFilter;
					gradientMap.magFilter = THREE.NearestFilter;

					loader.load( path, function ( gltf ) {

						var scene = gltf.scene;

						var camera;

						scene.traverse( function ( child ) {

							if ( child.isPerspectiveCamera ) {

								camera = child;
								camera.userData.vFov = camera.fov;

							}

							if ( child.isLight ) {

								child.castShadow = true;
								child.shadow.mapSize.set( 1024, 1024 );

							}

							if ( child.isMesh && child.material.isMeshStandardMaterial ) {

								child.castShadow = true;
								child.receiveShadow = true;

								var color = child.material.color;

								child.material = new THREE.MeshToonMaterial( {
									color: color,
									specular: 0x000000,
									gradientMap: gradientMap
								} );

							}

						} );

						var mixer = new THREE.AnimationMixer( scene );
						gltf.animations.forEach( function ( clip ) {

							mixer.clipAction( clip ).play();
							scene.userData.duration = clip.duration;

						} );

						scene.userData.camera = camera;
						scene.userData.element = element;
						scene.userData.mixer = mixer;

						scenes.push( scene );

						needsRender = true;

					} );

				}

			}

			function updateSize() {

				var width = canvas.clientWidth;
				var height = canvas.clientHeight;
				var dpr = window.devicePixelRatio;

				if ( canvas.width !== width * dpr || canvas.height !== height * dpr ) {

					renderer.setSize( width, height, false );
					needsRender = true;

				}

			}

			function animate() {

				render();
				requestAnimationFrame( animate );

			}

			function render() {

				updateSize();

				if ( lastScrollY !== window.scrollY ) {

					lastScrollY = window.scrollY;
					needsRender = true;

				}

				if ( needsRender === false ) return;

				// canvas.style.transform = `translateY(${window.scrollY}px)`;

				renderer.setScissorTest( false );
				renderer.clear();

				renderer.setScissorTest( true );

				scenes.forEach( function ( scene ) {

					var element = scene.userData.element;
					var rect = element.getBoundingClientRect();

					if ( rect.bottom < 0 || rect.top > renderer.domElement.clientHeight ||
						 rect.right < 0 || rect.left > renderer.domElement.clientWidth ) {

						return; // it's off screen

					}

					var width = rect.right - rect.left;
					var height = rect.bottom - rect.top;
					var left = rect.left;
					var bottom = renderer.domElement.clientHeight - rect.bottom;

					renderer.setViewport( left, bottom, width, height );
					renderer.setScissor( left, bottom, width, height );

					var camera = scene.userData.camera;
					camera.aspect = rect.width / rect.height;
					camera.fov = camera.userData.vFov;

					if ( camera.aspect < 1 ) {
						// Use horizontal fov in vertical aspect ratios
						camera.fov = Math.atan( Math.tan( camera.fov * Math.PI / 360 ) / camera.aspect ) * 360 / Math.PI;
					}

					camera.updateProjectionMatrix();

					var time = THREE.Math.mapLinear( rect.top, renderer.domElement.clientHeight, - rect.height, 0, 1 );
					var duration = scene.userData.duration;

					var mixer = scene.userData.mixer;
					mixer.setTime( time * duration );

					renderer.render( scene, camera );

				} );

				needsRender = false;

			}

		</script>
	</body>
</html>
